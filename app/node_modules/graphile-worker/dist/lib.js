"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const pg_1 = require("pg");
const config_1 = require("./config");
const helpers_1 = require("./helpers");
const logger_1 = require("./logger");
const migrate_1 = require("./migrate");
const _sharedOptionsCache = new WeakMap();
function processSharedOptions(options, { scope } = {}) {
    let compiled = _sharedOptionsCache.get(options);
    if (!compiled) {
        const { logger = logger_1.defaultLogger, schema: workerSchema = config_1.defaults.schema, } = options;
        const escapedWorkerSchema = pg_1.Client.prototype.escapeIdentifier(workerSchema);
        compiled = {
            logger,
            workerSchema,
            escapedWorkerSchema,
            maxContiguousErrors: config_1.defaults.maxContiguousErrors,
        };
        _sharedOptionsCache.set(options, compiled);
    }
    if (scope) {
        return Object.assign(Object.assign({}, compiled), { logger: compiled.logger.scope(scope) });
    }
    else {
        return compiled;
    }
}
exports.processSharedOptions = processSharedOptions;
async function assertPool(options, releasers) {
    const { logger } = processSharedOptions(options);
    assert(!options.pgPool || !options.connectionString, "Both `pgPool` and `connectionString` are set, at most one of these options should be provided");
    let pgPool;
    if (options.pgPool) {
        pgPool = options.pgPool;
    }
    else if (options.connectionString) {
        pgPool = new pg_1.Pool({
            connectionString: options.connectionString,
            max: options.maxPoolSize,
        });
        releasers.push(() => pgPool.end());
    }
    else if (process.env.DATABASE_URL) {
        pgPool = new pg_1.Pool({
            connectionString: process.env.DATABASE_URL,
            max: options.maxPoolSize,
        });
        releasers.push(() => pgPool.end());
    }
    else {
        throw new Error("You must either specify `pgPool` or `connectionString`, or you must make the `DATABASE_URL` environmental variable available.");
    }
    pgPool.on("error", err => {
        /*
         * This handler is required so that client connection errors don't bring
         * the server down (via `unhandledError`).
         *
         * `pg` will automatically terminate the client and remove it from the
         * pool, so we don't actually need to take any action here, just ensure
         * that the event listener is registered.
         */
        logger.error(`PostgreSQL client generated error: ${err.message}`, {
            error: err,
        });
    });
    return pgPool;
}
exports.assertPool = assertPool;
async function withReleasers(callback) {
    const releasers = [];
    const release = async () => {
        await Promise.all(releasers.map(fn => fn()));
    };
    try {
        return await callback(releasers, release);
    }
    catch (e) {
        try {
            await release();
        }
        catch (e2) {
            /* noop */
        }
        throw e;
    }
}
exports.withReleasers = withReleasers;
exports.getUtilsAndReleasersFromOptions = async (options, settings = {}) => {
    const shared = processSharedOptions(options, settings);
    const { concurrency = config_1.defaults.concurrentJobs } = options;
    return withReleasers(async (releasers, release) => {
        var _a, _b;
        const pgPool = await assertPool(options, releasers);
        // @ts-ignore
        const max = ((_b = (_a = pgPool) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.max) || 10;
        if (max < concurrency) {
            console.warn(`WARNING: having maxPoolSize (${max}) smaller than concurrency (${concurrency}) may lead to non-optimal performance.`);
        }
        const withPgClient = helpers_1.makeWithPgClientFromPool(pgPool);
        // Migrate
        await withPgClient(client => migrate_1.migrate(options, client));
        const addJob = helpers_1.makeAddJob(options, withPgClient);
        return Object.assign(Object.assign({}, shared), { pgPool,
            withPgClient,
            addJob,
            release,
            releasers });
    });
};
//# sourceMappingURL=lib.js.map