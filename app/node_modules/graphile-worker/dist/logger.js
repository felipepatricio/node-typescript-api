"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Inspired by the 'winston' levels: https://github.com/winstonjs/winston#logging-levels
var LogLevel;
(function (LogLevel) {
    LogLevel["ERROR"] = "error";
    LogLevel["WARNING"] = "warning";
    LogLevel["INFO"] = "info";
    LogLevel["DEBUG"] = "debug";
})(LogLevel = exports.LogLevel || (exports.LogLevel = {}));
class Logger {
    constructor(logFactory, scope = {}) {
        this._scope = scope;
        this._logFactory = logFactory;
        this.log = logFactory(scope);
    }
    scope(additionalScope) {
        return new Logger(this._logFactory, Object.assign(Object.assign({}, this._scope), additionalScope));
    }
    error(message, meta) {
        return this.log(LogLevel.ERROR, message, meta);
    }
    warn(message, meta) {
        return this.log(LogLevel.WARNING, message, meta);
    }
    info(message, meta) {
        return this.log(LogLevel.INFO, message, meta);
    }
    debug(message, meta) {
        return this.log(LogLevel.DEBUG, message, meta);
    }
}
exports.Logger = Logger;
// The default console logger does not output metadata
exports.consoleLogFactory = (scope) => (level, message) => {
    if (level === LogLevel.DEBUG && !process.env.GRAPHILE_WORKER_DEBUG) {
        return;
    }
    let method = (() => {
        switch (level) {
            case LogLevel.ERROR:
                return "error";
            case LogLevel.WARNING:
                return "warn";
            case LogLevel.INFO:
                return "info";
            default:
                return "log";
        }
    })();
    console[method](`[%s%s] %s: %s`, scope.label || "core", scope.workerId
        ? `(${scope.workerId}${scope.taskIdentifier ? `: ${scope.taskIdentifier}` : ""}${scope.jobId ? `{${scope.jobId}}` : ""})`
        : "", level.toUpperCase(), message);
};
exports.defaultLogger = new Logger(exports.consoleLogFactory);
//# sourceMappingURL=logger.js.map