"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const assert = require("assert");
const getTasks_1 = require("./getTasks");
const lib_1 = require("./lib");
const main_1 = require("./main");
const migrate_1 = require("./migrate");
exports.runMigrations = async (options) => {
    const { withPgClient, release } = await lib_1.getUtilsAndReleasersFromOptions(options);
    try {
        await withPgClient(client => migrate_1.migrate(options, client));
    }
    finally {
        await release();
    }
};
async function assertTaskList(options, releasers) {
    let taskList;
    assert(!options.taskDirectory || !options.taskList, "Exactly one of either `taskDirectory` or `taskList` should be set");
    if (options.taskList) {
        taskList = options.taskList;
    }
    else if (options.taskDirectory) {
        const watchedTasks = await getTasks_1.default(options, options.taskDirectory, false);
        releasers.push(() => watchedTasks.release());
        taskList = watchedTasks.tasks;
    }
    else {
        throw new Error("You must specify either `options.taskList` or `options.taskDirectory`");
    }
    return taskList;
}
exports.runOnce = async (options, overrideTaskList) => {
    const { concurrency = 1 } = options;
    const { withPgClient, release, releasers, } = await lib_1.getUtilsAndReleasersFromOptions(options);
    try {
        const taskList = overrideTaskList || (await assertTaskList(options, releasers));
        const promises = [];
        for (let i = 0; i < concurrency; i++) {
            promises.push(withPgClient(client => main_1.runTaskListOnce(options, taskList, client)));
        }
        await Promise.all(promises);
    }
    finally {
        await release();
    }
};
exports.run = async (options, overrideTaskList) => {
    const { pgPool, release, releasers, addJob, } = await lib_1.getUtilsAndReleasersFromOptions(options);
    try {
        const taskList = overrideTaskList || (await assertTaskList(options, releasers));
        const workerPool = main_1.runTaskList(options, taskList, pgPool);
        releasers.push(() => workerPool.release());
        let running = true;
        return {
            async stop() {
                if (running) {
                    running = false;
                    await release();
                }
                else {
                    throw new Error("Runner is already stopped");
                }
            },
            addJob,
            promise: workerPool.promise,
        };
    }
    catch (e) {
        await release();
        throw e;
    }
};
//# sourceMappingURL=runner.js.map