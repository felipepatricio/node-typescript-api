import sift from 'sift/sift.csp.min';

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

var getDefaultMessage = function getDefaultMessage(error) {
  return "Cannot execute \"" + error.action + "\" on \"" + error.subjectName + "\"";
};

var defaultErrorMessage = getDefaultMessage;
var ForbiddenError =
/*#__PURE__*/
function (_Error) {
  _inheritsLoose(ForbiddenError, _Error);

  ForbiddenError.setDefaultMessage = function setDefaultMessage(messageOrFn) {
    if (messageOrFn === null) {
      defaultErrorMessage = getDefaultMessage;
    } else {
      defaultErrorMessage = typeof messageOrFn === 'string' ? function () {
        return messageOrFn;
      } : messageOrFn;
    }
  };

  ForbiddenError.from = function from(ability) {
    var error = new this('');
    Object.defineProperty(error, 'ability', {
      value: ability
    });
    return error;
  };

  function ForbiddenError(message, options) {
    var _this;

    if (options === void 0) {
      options = {};
    }

    _this = _Error.call(this, message) || this;

    _this._setMetadata(options);

    _this.message = message || defaultErrorMessage(_assertThisInitialized(_this));
    _this._customMessage = null;

    if (typeof Error.captureStackTrace === 'function') {
      _this.name = _this.constructor.name;
      Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
    }

    return _this;
  }

  var _proto = ForbiddenError.prototype;

  _proto.setMessage = function setMessage(message) {
    this._customMessage = message;
    return this;
  };

  _proto.throwUnlessCan = function throwUnlessCan(action, subject, field) {
    if (!this.ability) {
      throw new ReferenceError('Cannot throw FordiddenError without respective ability instance');
    }

    var rule = this.ability.relevantRuleFor(action, subject, field);

    if (rule && !rule.inverted) {
      return;
    }

    this._setMetadata({
      action: action,
      subject: subject,
      field: field,
      subjectName: this.ability.subjectName(subject)
    });

    var reason = rule ? rule.reason : '';
    this.message = this._customMessage || reason || defaultErrorMessage(this);
    throw this; // eslint-disable-line
  };

  _proto._setMetadata = function _setMetadata(options) {
    this.subject = options.subject;
    this.subjectName = options.subjectName;
    this.action = options.action;
    this.field = options.field;
  };

  return ForbiddenError;
}(_wrapNativeSuper(Error));

function wrapArray(value) {
  return Array.isArray(value) ? value : [value];
}
function getSubjectName(subject) {
  if (!subject || typeof subject === 'string') {
    return subject;
  }

  var Type = typeof subject === 'object' ? subject.constructor : subject;
  return Type.modelName || Type.name;
}
function clone(object) {
  return JSON.parse(JSON.stringify(object));
}

var REGEXP_SPECIAL_CHARS = /[-/\\^$+?.()|[\]{}]/g;
var REGEXP_ANY = /\.?\*+\.?/g;
var REGEXP_STARS = /\*+/;
var REGEXP_DOT = /\./g;

function detectRegexpPattern(match, index, string) {
  var quantifier = string[0] === '*' || match[0] === '.' && match[match.length - 1] === '.' ? '+' : '*';
  var matcher = match.indexOf('**') === -1 ? '[^.]' : '.';
  var pattern = match.replace(REGEXP_DOT, '\\$&').replace(REGEXP_STARS, matcher + quantifier);
  return index + match.length === string.length ? "(?:" + pattern + ")?" : pattern;
}

function escapeRegexp(match, index, string) {
  if (match === '.' && (string[index - 1] === '*' || string[index + 1] === '*')) {
    return match;
  }

  return "\\" + match;
}

function createPattern(fields) {
  var patterns = fields.map(function (field) {
    return field.replace(REGEXP_SPECIAL_CHARS, escapeRegexp).replace(REGEXP_ANY, detectRegexpPattern);
  });
  var pattern = patterns.length > 1 ? "(?:" + patterns.join('|') + ")" : patterns[0];
  return new RegExp("^" + pattern + "$");
}

var Rule =
/*#__PURE__*/
function () {
  function Rule(params) {
    this.actions = params.actions || params.action;
    this.subject = params.subject;
    this.fields = !params.fields || params.fields.length === 0 ? undefined : wrapArray(params.fields);
    Object.defineProperty(this, '_fieldsPattern', {
      writable: true
    });
    this.inverted = !!params.inverted;
    this.conditions = params.conditions;
    Object.defineProperty(this, '_matches', {
      writable: true,
      value: this.conditions ? sift(this.conditions) : undefined
    });
    this.reason = params.reason;
  }

  var _proto = Rule.prototype;

  _proto.matches = function matches(object) {
    if (!this._matches) {
      return true;
    }

    if (typeof object === 'string') {
      return !this.inverted;
    }

    return this._matches(object);
  };

  _proto.isRelevantFor = function isRelevantFor(object, field) {
    if (!this.fields) {
      return true;
    }

    if (!field) {
      return !this.inverted;
    }

    return this.matchesField(field);
  };

  _proto.matchesField = function matchesField(field) {
    if (typeof this._fieldsPattern === 'undefined') {
      this._fieldsPattern = this.fields.join('').indexOf('*') === -1 ? null : createPattern(this.fields);
    }

    if (this._fieldsPattern === null || field.indexOf('*') !== -1) {
      return this.fields.indexOf(field) !== -1;
    }

    return this._fieldsPattern.test(field);
  };

  return Rule;
}();

var PRIVATE_FIELD = typeof Symbol !== 'undefined' ? Symbol('private') : "__" + Date.now();
var DEFAULT_ALIASES = {
  crud: ['create', 'read', 'update', 'delete']
};

function hasAction(action, actions) {
  return action === actions || Array.isArray(actions) && actions.indexOf(action) !== -1;
}

var Ability =
/*#__PURE__*/
function () {
  Ability.addAlias = function addAlias(alias, actions) {
    if (alias === 'manage' || hasAction('manage', actions)) {
      throw new Error('Cannot add alias for "manage" action because it represents any action');
    }

    if (hasAction(alias, actions)) {
      throw new Error("Attempt to alias action to itself: " + alias + " -> " + actions.toString());
    }

    DEFAULT_ALIASES[alias] = actions;
    return this;
  };

  function Ability(rules, options) {
    if (options === void 0) {
      options = {};
    }

    Object.defineProperty(this, 'subjectName', {
      value: options.subjectName || getSubjectName
    });
    this[PRIVATE_FIELD] = {
      RuleType: options.RuleType || Rule,
      originalRules: rules || [],
      hasPerFieldRules: false,
      indexedRules: Object.create(null),
      mergedRules: Object.create(null),
      events: {},
      aliases: clone(DEFAULT_ALIASES)
    };
    this.update(rules);
  }

  var _proto = Ability.prototype;

  _proto.update = function update(rules) {
    if (!Array.isArray(rules)) {
      return this;
    }

    var payload = {
      rules: rules,
      ability: this
    };
    this.emit('update', payload);
    this[PRIVATE_FIELD].originalRules = rules.slice(0);
    this[PRIVATE_FIELD].mergedRules = Object.create(null);
    var index = this.buildIndexFor(rules);

    if (process.env.NODE_ENV !== 'production' && index.isAllInverted && rules.length) {
      // eslint-disable-next-line
      console.warn('[casl]: Ability contains only inverted rules. That means user will not be able to do any actions. This will be changed to Error throw in the next major version');
    }

    this[PRIVATE_FIELD].indexedRules = index.rules;
    this[PRIVATE_FIELD].hasPerFieldRules = index.hasPerFieldRules;
    this.emit('updated', payload);
    return this;
  };

  _proto.buildIndexFor = function buildIndexFor(rules) {
    var indexedRules = Object.create(null);
    var RuleType = this[PRIVATE_FIELD].RuleType;
    var isAllInverted = true;
    var hasPerFieldRules = false;

    for (var i = 0; i < rules.length; i++) {
      var rule = new RuleType(rules[i]);
      var actions = this.expandActions(rule.actions);
      var subjects = wrapArray(rule.subject);
      var priority = rules.length - i - 1;
      isAllInverted = !!(isAllInverted && rule.inverted);

      if (!hasPerFieldRules && rule.fields) {
        hasPerFieldRules = true;
      }

      for (var k = 0; k < subjects.length; k++) {
        var subject = subjects[k];
        indexedRules[subject] = indexedRules[subject] || Object.create(null);

        for (var j = 0; j < actions.length; j++) {
          var action = actions[j];
          indexedRules[subject][action] = indexedRules[subject][action] || Object.create(null);
          indexedRules[subject][action][priority] = rule;
        }
      }
    }

    return {
      isAllInverted: isAllInverted,
      hasPerFieldRules: hasPerFieldRules,
      rules: indexedRules
    };
  };

  _proto.expandActions = function expandActions(rawActions) {
    var aliases = this[PRIVATE_FIELD].aliases;
    var actions = wrapArray(rawActions);
    var i = 0;

    while (i < actions.length) {
      var action = actions[i++];

      if (aliases.hasOwnProperty(action)) {
        actions = actions.concat(aliases[action]);
      }
    }

    return actions;
  };

  _proto.can = function can(action, subject, field) {
    if (field && typeof field !== 'string') {
      // eslint-disable-next-line
      throw new Error('Ability.can expects 3rd parameter to be a string. See https://stalniy.github.io/casl/abilities/2017/07/21/check-abilities.html#checking-fields for details');
    }

    var rule = this.relevantRuleFor(action, subject, field);
    return !!rule && !rule.inverted;
  };

  _proto.relevantRuleFor = function relevantRuleFor(action, subject, field) {
    var rules = this.rulesFor(action, subject, field);

    for (var i = 0; i < rules.length; i++) {
      if (rules[i].matches(subject)) {
        return rules[i];
      }
    }

    return null;
  };

  _proto.possibleRulesFor = function possibleRulesFor(action, subject) {
    var subjectName = this.subjectName(subject);
    var mergedRules = this[PRIVATE_FIELD].mergedRules;
    var key = subjectName + "_" + action;

    if (!mergedRules[key]) {
      mergedRules[key] = this.mergeRulesFor(action, subjectName);
    }

    return mergedRules[key];
  };

  _proto.mergeRulesFor = function mergeRulesFor(action, subjectName) {
    var indexedRules = this[PRIVATE_FIELD].indexedRules;
    var mergedRules = [subjectName, 'all'].reduce(function (rules, subjectType) {
      var subjectRules = indexedRules[subjectType];

      if (!subjectRules) {
        return rules;
      }

      return Object.assign(rules, subjectRules[action], subjectRules.manage);
    }, []); // TODO: think whether there is a better way to prioritize rules
    // or convert sparse array to regular one

    return mergedRules.filter(Boolean);
  };

  _proto.rulesFor = function rulesFor(action, subject, field) {
    var rules = this.possibleRulesFor(action, subject);

    if (!this[PRIVATE_FIELD].hasPerFieldRules) {
      return rules;
    }

    return rules.filter(function (rule) {
      return rule.isRelevantFor(subject, field);
    });
  };

  _proto.cannot = function cannot() {
    return !this.can.apply(this, arguments);
  };

  _proto.throwUnlessCan = function throwUnlessCan() {
    var _ForbiddenError$from;

    console.warn("\n      Ability.throwUnlessCan is deprecated and will be removed in 4.x version.\n      Please use \"ForbiddenError.from(ability).throwUnlessCan(...)\" instead.\n    ".trim());

    (_ForbiddenError$from = ForbiddenError.from(this)).throwUnlessCan.apply(_ForbiddenError$from, arguments);
  };

  _proto.on = function on(event, handler) {
    var events = this[PRIVATE_FIELD].events;
    var isAttached = true;

    if (!events[event]) {
      events[event] = [];
    }

    events[event].push(handler);
    return function () {
      if (isAttached) {
        var index = events[event].indexOf(handler);
        events[event].splice(index, 1);
        isAttached = false;
      }
    };
  };

  _proto.emit = function emit(event, payload) {
    var handlers = this[PRIVATE_FIELD].events[event];

    if (handlers) {
      handlers.slice(0).forEach(function (handler) {
        return handler(payload);
      });
    }
  };

  _createClass(Ability, [{
    key: "rules",
    get: function get() {
      return this[PRIVATE_FIELD].originalRules;
    }
  }]);

  return Ability;
}();

function isStringOrNonEmptyArray(value) {
  return ![].concat(value).some(function (item) {
    return typeof item !== 'string';
  });
}

function isObject(value) {
  return value && typeof value === 'object';
}

var RuleBuilder =
/*#__PURE__*/
function () {
  function RuleBuilder(rule) {
    this.rule = rule;
  }

  var _proto = RuleBuilder.prototype;

  _proto.because = function because(reason) {
    this.rule.reason = reason;
    return this;
  };

  return RuleBuilder;
}();
var AbilityBuilder =
/*#__PURE__*/
function () {
  AbilityBuilder.define = function define(params, dsl) {
    var options = typeof params === 'function' ? {} : params;
    var define = params === options ? dsl : params;
    var builder = new this(options);
    var result = define(builder.can.bind(builder), builder.cannot.bind(builder));

    var buildAbility = function buildAbility() {
      return new Ability(builder.rules, options);
    };

    return result && typeof result.then === 'function' ? result.then(buildAbility) : buildAbility();
  };

  AbilityBuilder.extract = function extract() {
    var builder = new this();
    return {
      can: builder.can.bind(builder),
      cannot: builder.cannot.bind(builder),
      rules: builder.rules
    };
  };

  function AbilityBuilder(_temp) {
    var _ref = _temp === void 0 ? {} : _temp,
        _ref$subjectName = _ref.subjectName,
        subjectName = _ref$subjectName === void 0 ? getSubjectName : _ref$subjectName;

    this.rules = [];
    this.subjectName = subjectName;
  }

  var _proto2 = AbilityBuilder.prototype;

  _proto2.can = function can(actions, subject, conditionsOrFields, conditions) {
    if (!isStringOrNonEmptyArray(actions)) {
      throw new TypeError('AbilityBuilder#can expects the first parameter to be an action or array of actions');
    }

    var subjectName = [].concat(subject).map(this.subjectName);

    if (!isStringOrNonEmptyArray(subjectName)) {
      throw new TypeError('AbilityBuilder#can expects the second argument to be a subject name/type or an array of subject names/types');
    }

    var rule = {
      actions: actions,
      subject: subjectName
    };

    if (Array.isArray(conditionsOrFields) || typeof conditionsOrFields === 'string') {
      rule.fields = conditionsOrFields;
    }

    if (isObject(conditions) || !rule.fields && isObject(conditionsOrFields)) {
      rule.conditions = conditions || conditionsOrFields;
    }

    this.rules.push(rule);
    return new RuleBuilder(rule);
  };

  _proto2.cannot = function cannot() {
    var builder = this.can.apply(this, arguments);
    builder.rule.inverted = true;
    return builder;
  };

  return AbilityBuilder;
}();

export { Ability, AbilityBuilder, ForbiddenError, Rule, RuleBuilder };
